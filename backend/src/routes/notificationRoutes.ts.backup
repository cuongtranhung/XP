/**
 * Notification System API Routes
 * RESTful endpoints for notification management
 */

import { Router, Request, Response, NextFunction } from 'express';
import { body, param, query, validationResult } from 'express-validator';
import { authenticate } from '../middleware/auth';
import { authorize } from '../middleware/authorize';
import { rateLimiter } from '../middleware/rateLimiter';
import { logger } from '../utils/logger';
// Temporarily comment out problematic service imports for testing
// import notificationService, { 
//   NotificationData, 
//   NotificationType, 
//   NotificationPriority,
//   NotificationChannel,
//   NotificationStatus
// } from '../services/notificationService';
// import notificationTemplateService from '../services/notificationTemplateService';
// import notificationQueueService from '../services/notificationQueueService';
import notificationPreferencesService from '../services/notificationPreferencesService';
// import notificationGroupingService from '../services/notificationGroupingService';
// import notificationSchedulingService from '../services/notificationSchedulingService';
// import notificationAnalyticsService from '../services/notificationAnalyticsService';

// Mock types for testing
export type NotificationType = 'email' | 'sms' | 'push' | 'in-app' | 'system' | 'marketing' | 'transactional';
export type NotificationPriority = 'critical' | 'high' | 'medium' | 'low';
export type NotificationChannel = 'email' | 'sms' | 'push' | 'in-app';
export type NotificationStatus = 'pending' | 'sent' | 'delivered' | 'failed' | 'read' | 'archived';

const router = Router();

/**
 * Validation middleware
 */
const validateRequest = (req: Request, res: Response, next: NextFunction) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ 
      success: false, 
      errors: errors.array() 
    });
  }
  next();
};

/**
 * @route   POST /api/notifications
 * @desc    Send a notification
 * @access  Private
 */
router.post(
  '/',
  authenticate,
  rateLimiter({ windowMs: 60000, max: 100 }),
  [
    body('userId').optional().isString(),
    body('type').isIn(['email', 'sms', 'push', 'in-app', 'system', 'marketing', 'transactional']),
    body('title').isString().isLength({ min: 1, max: 200 }),
    body('message').isString().isLength({ min: 1, max: 5000 }),
    body('priority').optional().isIn(['critical', 'high', 'medium', 'low']),
    body('channels').optional().isArray(),
    body('channels.*').optional().isIn(['email', 'sms', 'push', 'in-app']),
    body('metadata').optional().isObject(),
    body('templateId').optional().isString(),
    body('templateData').optional().isObject(),
    body('schedule').optional().isISO8601(),
    body('groupKey').optional().isString()
  ],
  validateRequest,
  async (req: Request, res: Response) => {
    try {
      const userId = req.body.userId || (req as any).user.id;
      
      // Check if notification should be grouped
      if (req.body.groupKey) {
        const groupResult = await notificationGroupingService.processNotification({
          ...req.body,
          userId,
          notificationId: `notif_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
          status: 'pending',
          createdAt: new Date()
        });
        
        if (groupResult.grouped && !groupResult.immediate) {
          return res.status(202).json({
            success: true,
            message: 'Notification grouped for later delivery',
            groupId: groupResult.groupId
          });
        }
      }
      
      // Check if notification should be scheduled
      if (req.body.schedule) {
        const scheduled = await notificationSchedulingService.scheduleNotification(
          {
            ...req.body,
            userId,
            notificationId: `notif_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            status: 'pending',
            createdAt: new Date()
          },
          {
            sendAt: new Date(req.body.schedule),
            timezone: req.body.timezone,
            recurring: req.body.recurring,
            conditions: req.body.conditions
          }
        );
        
        return res.status(202).json({
          success: true,
          message: 'Notification scheduled',
          scheduleId: scheduled.scheduleId,
          scheduledFor: scheduled.scheduledFor
        });
      }
      
      // Send notification immediately
      const notification = await notificationService.createNotification({
        userId,
        type: req.body.type,
        title: req.body.title,
        message: req.body.message,
        priority: req.body.priority || 'medium',
        channels: req.body.channels || [],
        metadata: req.body.metadata || {},
        status: 'pending',
        createdAt: new Date()
      });
      
      res.status(201).json({
        success: true,
        notification
      });
      
    } catch (error) {
      logger.error('Failed to send notification', { error });
      res.status(500).json({
        success: false,
        message: 'Failed to send notification',
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  }
);

/**
 * @route   POST /api/notifications/batch
 * @desc    Send batch notifications
 * @access  Private/Admin
 */
router.post(
  '/batch',
  authenticate,
  authorize(['admin', 'system']),
  rateLimiter({ windowMs: 60000, max: 10 }),
  [
    body('notifications').isArray().isLength({ min: 1, max: 1000 }),
    body('notifications.*.userId').isString(),
    body('notifications.*.type').isIn(['email', 'sms', 'push', 'in-app', 'system', 'marketing', 'transactional']),
    body('notifications.*.title').isString(),
    body('notifications.*.message').isString(),
    body('batchOptions').optional().isObject(),
    body('batchOptions.name').optional().isString(),
    body('batchOptions.schedule').optional().isObject()
  ],
  validateRequest,
  async (req: Request, res: Response) => {
    try {
      const { notifications, batchOptions } = req.body;
      
      // Process batch with grouping service
      if (batchOptions) {
        const batch = await notificationGroupingService.createBatch({
          name: batchOptions.name || 'Batch Notification',
          criteria: batchOptions.criteria || {},
          schedule: batchOptions.schedule,
          limits: batchOptions.limits || {},
          priority: batchOptions.priority || 'medium',
          enabled: true
        });
        
        const results = await notificationGroupingService.processBatch(
          batch.batchId,
          notifications.map((n: any) => ({
            ...n,
            notificationId: `notif_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            status: 'pending',
            createdAt: new Date()
          }))
        );
        
        return res.status(202).json({
          success: true,
          batchId: batch.batchId,
          results
        });
      }
      
      // Send batch immediately
      const results = await Promise.allSettled(
        notifications.map((notification: any) =>
          notificationService.createNotification({
            ...notification,
            status: 'pending',
            createdAt: new Date()
          })
        )
      );
      
      const successful = results.filter(r => r.status === 'fulfilled').length;
      const failed = results.filter(r => r.status === 'rejected').length;
      
      res.status(200).json({
        success: true,
        total: notifications.length,
        successful,
        failed,
        results: results.map((r, i) => ({
          index: i,
          success: r.status === 'fulfilled',
          data: r.status === 'fulfilled' ? r.value : null,
          error: r.status === 'rejected' ? r.reason?.message : null
        }))
      });
      
    } catch (error) {
      logger.error('Failed to send batch notifications', { error });
      res.status(500).json({
        success: false,
        message: 'Failed to send batch notifications',
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  }
);

/**
 * @route   GET /api/notifications
 * @desc    Get user notifications
 * @access  Private
 */
router.get(
  '/',
  authenticate,
  [
    query('status').optional().isIn(['pending', 'sent', 'delivered', 'failed', 'read', 'archived']),
    query('type').optional().isIn(['email', 'sms', 'push', 'in-app', 'system', 'marketing', 'transactional']),
    query('channel').optional().isIn(['email', 'sms', 'push', 'in-app']),
    query('limit').optional().isInt({ min: 1, max: 100 }),
    query('offset').optional().isInt({ min: 0 }),
    query('from').optional().isISO8601(),
    query('to').optional().isISO8601()
  ],
  validateRequest,
  async (req: Request, res: Response) => {
    try {
      const userId = (req as any).user.id;
      const filters = {
        status: req.query.status as NotificationStatus,
        type: req.query.type as NotificationType,
        channel: req.query.channel as NotificationChannel,
        from: req.query.from ? new Date(req.query.from as string) : undefined,
        to: req.query.to ? new Date(req.query.to as string) : undefined
      };
      
      const notifications = await notificationService.getUserNotifications(
        userId,
        filters,
        {
          limit: parseInt(req.query.limit as string) || 50,
          offset: parseInt(req.query.offset as string) || 0
        }
      );
      
      res.json({
        success: true,
        notifications
      });
      
    } catch (error) {
      logger.error('Failed to get notifications', { error });
      res.status(500).json({
        success: false,
        message: 'Failed to get notifications',
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  }
);

/**
 * @route   GET /api/notifications/:id
 * @desc    Get notification by ID
 * @access  Private
 */
router.get(
  '/:id',
  authenticate,
  [param('id').isString()],
  validateRequest,
  async (req: Request, res: Response) => {
    try {
      const notification = await notificationService.getNotification(req.params.id);
      
      if (!notification) {
        return res.status(404).json({
          success: false,
          message: 'Notification not found'
        });
      }
      
      // Check if user has access to this notification
      const userId = (req as any).user.id;
      if (notification.userId !== userId && !(req as any).user.roles?.includes('admin')) {
        return res.status(403).json({
          success: false,
          message: 'Access denied'
        });
      }
      
      res.json({
        success: true,
        notification
      });
      
    } catch (error) {
      logger.error('Failed to get notification', { error });
      res.status(500).json({
        success: false,
        message: 'Failed to get notification',
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  }
);

/**
 * @route   PUT /api/notifications/:id/read
 * @desc    Mark notification as read
 * @access  Private
 */
router.put(
  '/:id/read',
  authenticate,
  [param('id').isString()],
  validateRequest,
  async (req: Request, res: Response) => {
    try {
      const userId = (req as any).user.id;
      const success = await notificationService.markAsRead(req.params.id, userId);
      
      if (!success) {
        return res.status(404).json({
          success: false,
          message: 'Notification not found or already read'
        });
      }
      
      // Track read event
      await notificationAnalyticsService.trackEvent({
        eventId: `event_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        eventType: 'opened',
        notificationId: req.params.id,
        userId,
        timestamp: new Date()
      });
      
      res.json({
        success: true,
        message: 'Notification marked as read'
      });
      
    } catch (error) {
      logger.error('Failed to mark notification as read', { error });
      res.status(500).json({
        success: false,
        message: 'Failed to mark notification as read',
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  }
);

/**
 * @route   PUT /api/notifications/read-all
 * @desc    Mark all notifications as read
 * @access  Private
 */
router.put(
  '/read-all',
  authenticate,
  async (req: Request, res: Response) => {
    try {
      const userId = (req as any).user.id;
      const count = await notificationService.markAllAsRead(userId);
      
      res.json({
        success: true,
        message: `${count} notifications marked as read`,
        count
      });
      
    } catch (error) {
      logger.error('Failed to mark all notifications as read', { error });
      res.status(500).json({
        success: false,
        message: 'Failed to mark all notifications as read',
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  }
);

/**
 * @route   DELETE /api/notifications/:id
 * @desc    Delete notification
 * @access  Private
 */
router.delete(
  '/:id',
  authenticate,
  [param('id').isString()],
  validateRequest,
  async (req: Request, res: Response) => {
    try {
      const userId = (req as any).user.id;
      const success = await notificationService.deleteNotification(req.params.id, userId);
      
      if (!success) {
        return res.status(404).json({
          success: false,
          message: 'Notification not found or access denied'
        });
      }
      
      res.json({
        success: true,
        message: 'Notification deleted'
      });
      
    } catch (error) {
      logger.error('Failed to delete notification', { error });
      res.status(500).json({
        success: false,
        message: 'Failed to delete notification',
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  }
);

/**
 * @route   GET /api/notifications/preferences
 * @desc    Get user notification preferences
 * @access  Private
 */
router.get(
  '/preferences',
  authenticate,
  async (req: Request, res: Response) => {
    try {
      const userId = (req as any).user.id;
      const preferences = await notificationPreferencesService.getUserPreferences(userId);
      
      res.json({
        success: true,
        preferences
      });
      
    } catch (error) {
      logger.error('Failed to get preferences', { error });
      res.status(500).json({
        success: false,
        message: 'Failed to get preferences',
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  }
);

/**
 * @route   PUT /api/notifications/preferences
 * @desc    Update user notification preferences
 * @access  Private
 */
router.put(
  '/preferences',
  authenticate,
  [
    body('channels').optional().isObject(),
    body('channels.email').optional().isBoolean(),
    body('channels.sms').optional().isBoolean(),
    body('channels.push').optional().isBoolean(),
    body('channels.in-app').optional().isBoolean(),
    body('types').optional().isObject(),
    body('quiet_hours').optional().isObject(),
    body('frequency').optional().isObject(),
    body('language').optional().isString(),
    body('timezone').optional().isString()
  ],
  validateRequest,
  async (req: Request, res: Response) => {
    try {
      const userId = (req as any).user.id;
      const preferences = await notificationPreferencesService.updateUserPreferences(
        userId,
        req.body
      );
      
      res.json({
        success: true,
        message: 'Preferences updated',
        preferences
      });
      
    } catch (error) {
      logger.error('Failed to update preferences', { error });
      res.status(500).json({
        success: false,
        message: 'Failed to update preferences',
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  }
);

/**
 * @route   POST /api/notifications/unsubscribe
 * @desc    Unsubscribe from notifications
 * @access  Public (with token)
 */
router.post(
  '/unsubscribe',
  [
    body('token').isString(),
    body('type').optional().isIn(['all', 'marketing', 'transactional', 'system']),
    body('channel').optional().isIn(['email', 'sms', 'push', 'in-app'])
  ],
  validateRequest,
  async (req: Request, res: Response) => {
    try {
      const { token, type, channel } = req.body;
      
      // Verify unsubscribe token
      const userId = await notificationService.verifyUnsubscribeToken(token);
      
      if (!userId) {
        return res.status(400).json({
          success: false,
          message: 'Invalid or expired unsubscribe token'
        });
      }
      
      // Update preferences
      if (type === 'all') {
        await notificationPreferencesService.unsubscribeAll(userId);
      } else if (type) {
        await notificationPreferencesService.unsubscribeFromType(userId, type);
      } else if (channel) {
        await notificationPreferencesService.disableChannel(userId, channel);
      }
      
      res.json({
        success: true,
        message: 'Successfully unsubscribed'
      });
      
    } catch (error) {
      logger.error('Failed to unsubscribe', { error });
      res.status(500).json({
        success: false,
        message: 'Failed to unsubscribe',
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  }
);

/**
 * @route   GET /api/notifications/templates
 * @desc    Get available notification templates
 * @access  Private
 */
router.get(
  '/templates',
  authenticate,
  [
    query('category').optional().isString(),
    query('channel').optional().isIn(['email', 'sms', 'push', 'in-app']),
    query('active').optional().isBoolean()
  ],
  validateRequest,
  async (req: Request, res: Response) => {
    try {
      const templates = await notificationTemplateService.getTemplates({
        category: req.query.category as string,
        channel: req.query.channel as any,
        active: req.query.active === 'true'
      });
      
      res.json({
        success: true,
        templates
      });
      
    } catch (error) {
      logger.error('Failed to get templates', { error });
      res.status(500).json({
        success: false,
        message: 'Failed to get templates',
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  }
);

/**
 * @route   GET /api/notifications/scheduled
 * @desc    Get scheduled notifications
 * @access  Private
 */
router.get(
  '/scheduled',
  authenticate,
  [
    query('status').optional().isIn(['pending', 'scheduled', 'processing', 'sent', 'failed', 'cancelled']),
    query('recurring').optional().isBoolean(),
    query('from').optional().isISO8601(),
    query('to').optional().isISO8601(),
    query('limit').optional().isInt({ min: 1, max: 100 })
  ],
  validateRequest,
  async (req: Request, res: Response) => {
    try {
      const userId = (req as any).user.id;
      
      const schedules = await notificationSchedulingService.getScheduledNotifications(
        userId,
        {
          status: req.query.status as any,
          recurring: req.query.recurring === 'true',
          from: req.query.from ? new Date(req.query.from as string) : undefined,
          to: req.query.to ? new Date(req.query.to as string) : undefined,
          limit: parseInt(req.query.limit as string) || 50
        }
      );
      
      res.json({
        success: true,
        schedules
      });
      
    } catch (error) {
      logger.error('Failed to get scheduled notifications', { error });
      res.status(500).json({
        success: false,
        message: 'Failed to get scheduled notifications',
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  }
);

/**
 * @route   DELETE /api/notifications/scheduled/:id
 * @desc    Cancel scheduled notification
 * @access  Private
 */
router.delete(
  '/scheduled/:id',
  authenticate,
  [param('id').isString()],
  validateRequest,
  async (req: Request, res: Response) => {
    try {
      const success = await notificationSchedulingService.cancelSchedule(req.params.id);
      
      if (!success) {
        return res.status(404).json({
          success: false,
          message: 'Schedule not found or already sent'
        });
      }
      
      res.json({
        success: true,
        message: 'Schedule cancelled'
      });
      
    } catch (error) {
      logger.error('Failed to cancel schedule', { error });
      res.status(500).json({
        success: false,
        message: 'Failed to cancel schedule',
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  }
);

/**
 * @route   GET /api/notifications/analytics
 * @desc    Get notification analytics
 * @access  Private
 */
router.get(
  '/analytics',
  authenticate,
  [
    query('from').optional().isISO8601(),
    query('to').optional().isISO8601(),
    query('type').optional().isIn(['email', 'sms', 'push', 'in-app', 'system', 'marketing', 'transactional']),
    query('channel').optional().isIn(['email', 'sms', 'push', 'in-app']),
    query('aggregation').optional().isIn(['hourly', 'daily', 'weekly', 'monthly'])
  ],
  validateRequest,
  async (req: Request, res: Response) => {
    try {
      const userId = (req as any).user.id;
      const isAdmin = (req as any).user.roles?.includes('admin');
      
      const analytics = await notificationAnalyticsService.getAggregatedAnalytics({
        from: req.query.from ? new Date(req.query.from as string) : undefined,
        to: req.query.to ? new Date(req.query.to as string) : undefined,
        userId: isAdmin ? undefined : userId,
        type: req.query.type as NotificationType,
        channel: req.query.channel as NotificationChannel,
        aggregation: req.query.aggregation as any || 'daily'
      });
      
      res.json({
        success: true,
        analytics
      });
      
    } catch (error) {
      logger.error('Failed to get analytics', { error });
      res.status(500).json({
        success: false,
        message: 'Failed to get analytics',
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  }
);

/**
 * @route   GET /api/notifications/analytics/engagement
 * @desc    Get user engagement analytics
 * @access  Private
 */
router.get(
  '/analytics/engagement',
  authenticate,
  async (req: Request, res: Response) => {
    try {
      const userId = (req as any).user.id;
      const engagement = await notificationAnalyticsService.getUserEngagement(userId);
      
      res.json({
        success: true,
        engagement
      });
      
    } catch (error) {
      logger.error('Failed to get engagement analytics', { error });
      res.status(500).json({
        success: false,
        message: 'Failed to get engagement analytics',
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  }
);

/**
 * @route   GET /api/notifications/analytics/performance
 * @desc    Get notification performance metrics
 * @access  Private/Admin
 */
router.get(
  '/analytics/performance',
  authenticate,
  authorize(['admin', 'system']),
  [
    query('period').optional().isIn(['1h', '24h', '7d', '30d']),
    query('channel').optional().isIn(['email', 'sms', 'push', 'in-app'])
  ],
  validateRequest,
  async (req: Request, res: Response) => {
    try {
      const period = req.query.period as string || '24h';
      const channel = req.query.channel as NotificationChannel;
      
      const performance = await notificationAnalyticsService.getPerformanceMetrics({
        period,
        channel
      });
      
      res.json({
        success: true,
        performance
      });
      
    } catch (error) {
      logger.error('Failed to get performance metrics', { error });
      res.status(500).json({
        success: false,
        message: 'Failed to get performance metrics',
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  }
);

/**
 * @route   POST /api/notifications/test
 * @desc    Send test notification
 * @access  Private/Admin
 */
router.post(
  '/test',
  authenticate,
  authorize(['admin', 'developer']),
  [
    body('channel').isIn(['email', 'sms', 'push', 'in-app']),
    body('recipient').optional().isString(),
    body('template').optional().isString(),
    body('data').optional().isObject()
  ],
  validateRequest,
  async (req: Request, res: Response) => {
    try {
      const userId = req.body.recipient || (req as any).user.id;
      
      const notification = await notificationService.createNotification({
        userId,
        type: 'system',
        title: 'Test Notification',
        message: `This is a test ${req.body.channel} notification sent at ${new Date().toISOString()}`,
        priority: 'low',
        channels: [req.body.channel],
        metadata: {
          isTest: true,
          templateId: req.body.template,
          templateData: req.body.data
        },
        status: 'pending',
        createdAt: new Date()
      });
      
      res.json({
        success: true,
        message: 'Test notification sent',
        notification
      });
      
    } catch (error) {
      logger.error('Failed to send test notification', { error });
      res.status(500).json({
        success: false,
        message: 'Failed to send test notification',
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  }
);

// Export router
export default router;